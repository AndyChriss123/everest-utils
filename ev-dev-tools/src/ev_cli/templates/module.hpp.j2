{% from "helper_macros.j2" import print_template_info, insert_block, cpp_type, print_spdx_line %}
{{ print_spdx_line('Apache-2.0') }}
#ifndef {{ info.hpp_guard }}
#define {{ info.hpp_guard }}

{% if requires %}
// interface headers for requirements
{% for req in requires %}
#include <generated/interface/{{ req.type }}_req.hpp>
{% endfor %}

{% endif %}
{% if provides %}
// interface headers for provided implementations
{% for impl in provides %}
#include <generated/interface/{{ impl.type }}_impl.hpp>
{% endfor %}

{% endif %}
namespace module {

namespace {{ manifest_json.name }} {
extern const char data[];
const size_t len = {{ manifest_json.length }};
}

{% if configs %}
//
// config related structures
//
{% for impl in configs.implementations %}
struct {{ impl.id }}Config {
    {% for item in impl.config %}
    {{ cpp_type(item) }} {{ item.name }};
    {% endfor %}
};

{% if loop.last %}
struct ImplementationConfigs {
    {% for impl in configs.implementations %}
    {{ impl.id }}Config {{ impl.id }};
    {% endfor %}
}

{% endif %}
{% endfor %}
{% if configs.module %}
struct ModuleConfig {
    {% for item in configs.module %}
    {{ cpp_type(item) }} {{ item.name }};
    {% endfor %}
};

{% endif %}
struct Configs {
    {% if configs.implementations %}
    ImplementationConfigs implementation;
    {% endif %}
    {% if configs.module %}
    ModuleConfig module;
    {% endif %}
};
{% endif %}

struct ImplementationList {
    {% for impl in provides %}
    everest::interface::{{ impl.type }}::Implementation {{ impl.id }};
    {% endfor %}
};

struct RunContext {
    {% if configs %}
    Configs config;
    {% endif %}
    {% for req in requires %}
    {% if req.is_vector %}
    std::vector<everest::interface::{{ req.type }}::RunRequiremnt> req_{{ req.id }};
    {% else %}
    everest::interface::{{ req.type }}::RunRequirement req_{{ req.id }};
    {% endif %}
    {% endfor %}
    {% for impl in provides %}
    everest::interface::{{ impl.type }}::Publishers impl_{{ impl.id }};
    {% endfor %}
    everest::ModuleInfo info;
};

struct BootContext {
    {% if configs %}
    Configs config;
    {% endif %}
    {% for req in requires %}
    {% if req.is_vector %}
    std::vector<everest::interface::{{ req.type }}::BootRequirement> req_{{ req.id }};
    {% else %}
    everest::interface::{{ req.type }}::BootRequirement req_{{ req.id }};
    {% endif %}
    {% endfor %}
    everest::ModuleInfo info;
};

using ModuleInit = std::function<ImplementationList&(BootContext&)>;
using ModuleReady = std::function<void(RunContext&)>;

class ModuleBase {
public:
    virtual ImplementationList mod_init(BootContext&) = 0;
    virtual void mod_ready(RunContext&) = 0;
};

void load(int argc, char* argv[], ModuleBase&);

}

#endif // {{ info.hpp_guard }}
