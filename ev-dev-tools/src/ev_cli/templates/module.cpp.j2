{% from "helper_macros.j2" import print_spdx_line, cpp_type, var_to_cpp, var_to_any, call_cmd_signature %}
{{ print_spdx_line('Apache-2.0') }}

#include <generated/module/{{ info.name }}.hpp>

namespace types = everest::types;

namespace module {

{% for impl in callable_provides %}
{% if loop.first %}
//
// provided interface implementations
//
{% endif %}
class {{ impl.type }}Impl : public everest::interface::{{ impl.type }}::Handlers {
public:
    {{ impl.type }}Impl(RunContext*& ctx) : ctx(ctx) {};
    {% for cmd in impl.tmpl.cmds %}
    {{ call_cmd_signature(cmd) }} override {
        // your code for cmd {{ cmd.name }} goes here
        {% if cmd.result %}
        return {{ cmd.result.json_type|create_dummy_result }};
        {% endif %}
    }
    {% endfor %}
private:
    RunContext* const& ctx;
};

{% endfor %}

//
// module implementation
//
class Module : public ModuleBase {
private:
    ImplementationList mod_init(BootContext& ctx) override {
        return {
            {% for impl in provides %}
            {% if impl.is_callable %}
            {{ impl.id }},
            {% else %}
            nullptr,
            {% endif %}
            {% endfor %}
        };
    };

    void mod_ready(RunContext& ctx) override{
        this->ctx = &ctx;
    };

    RunContext* ctx;
    {% for impl in callable_provides %}
    {{ impl.type }}Impl {{ impl.id }}{ ctx };
    {% endfor %}
};

}

int main(int argc, char* argv[]) {
    module::Module mod;

    module::load(argc, argv, mod);
    return 0;
}
