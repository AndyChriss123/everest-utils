{% from "helper_macros.j2" import print_spdx_line, unfold_result, unfold_argument, unfold_arguments %}
{{ print_spdx_line('Apache-2.0') }}
#ifndef {{ info.hpp_guard }}
#define {{ info.hpp_guard }}

#include <functional>
#include <string>

#include <everest/generated_module_fwd.hpp>

namespace everest::interface::{{ info.interface }} {

extern std::string get_definition();

struct Publishers {
    Publishers(const ImplementationContext&);
    {% for var in vars %}
    void publish_{{ var.name }}({% if var.json_type != 'null' %}{{ unfold_argument(var, false) }}{% endif %});
    {% endfor %}

private:
    ImplementationContext ctx;
};

{% if cmds %}
class Handlers {
protected:
    {% for cmd in cmds %}
    virtual {{ unfold_result(cmd.result) }}handle_{{ cmd.name }}{{ unfold_arguments(cmd.args) }} = 0;
    {% endfor %}
    Publishers* vars {};

private:
    void do_register(const ImplementationContext&, Publishers*);
    friend class Implementation;
};

struct Callbacks {
    {% for cmd in cmds %}
    std::function<{{ unfold_result(cmd.result) }}{{ unfold_arguments(cmd.args)}}> handle_{{ cmd.name }};
    {% endfor %}

private:
    void do_register(const ImplementationContext&);
    friend class Implementation;
};

class Implementation {
public:
    Implementation(Handlers& handlers) : handlers(&handlers){};
    Implementation(Callbacks& callbacks) : callbacks(&callbacks){};

    // FIXME: (aw): this function is visible on the ImplementationList items
    void do_register(const ImplementationContext&, Publishers*);
private:
    Handlers* handlers{nullptr};
    Callbacks* callbacks{nullptr};
};

{% else %}
class Implementation {
public:
    Implementation(std::nullptr_t null) {};
    void do_register(const ImplementationContext&, Publishers* vars) {};
};

{% endif %}

}

#endif // {{ info.hpp_guard }}
