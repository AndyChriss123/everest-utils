{% from "helper_macros.j2" import print_spdx_line, result_type, cpp_type, var_to_cpp, call_cmd_signature, publish_var_signature %}
{{ print_spdx_line('Apache-2.0') }}
#ifndef {{ info.hpp_guard }}
#define {{ info.hpp_guard }}

#include <everest/utils/interface_defs.hpp>

namespace everest::interface::{{ info.interface }} {

struct Publishers {
    Publishers(Everest* ev, const std::string& impl_id) : _ev(ev), _impl_id(impl_id) {};
    {% for var in vars %}
    {{ publish_var_signature(var) }};
    {% endfor %}

private:
    Everest* _ev;
    std::string _impl_id;
};

{% if cmds %}
class Handlers {
protected:
    {% for cmd in cmds %}
    virtual {{ call_cmd_signature(cmd) }} = 0;
    {% endfor %}
    {% if vars %}
    Publishers* vars {};
    {% endif %}

private:
    void do_register(Everest* ev{{ ', Publishers* vars' if vars }});
    friend class Implementation;
};

struct Callbacks {
    {% for cmd in cmds %}
    std::function<{{ result_type(cmd.result) }}({% for arg in cmd.args %}{{ cpp_type(arg) }}{{ ', ' if not loop.last }}{% endfor %})> handle_{{ cmd.name }};
    {% endfor %}

private:
    void do_register(Everest* ev);
    friend class Implementation;
};

class Implementation {
public:
    Implementation(Handlers& handlers) : handlers(&handlers){};
    Implementation(Callbacks& callbacks) : callbacks(&callbacks){};

    // FIXME: (aw): this function is visible on the ImplementationList items
    void do_register(Everest* ev, Publishers* vars);
private:
    Handlers* handlers{nullptr};
    Callbacks* callbacks{nullptr};
};

{% else %}
class Implementation {
public:
    Implementation(std::nullptr_t null) {};
    void do_register(Everest* ev, Publishers* vars) {};
};

{% endif %}

}

#endif // {{ info.hpp_guard }}
