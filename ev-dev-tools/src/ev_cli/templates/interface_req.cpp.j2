{% from "helper_macros.j2" import print_spdx_line, cpp_type, var_to_cpp, var_to_any, call_cmd_signature %}
{{ print_spdx_line('Apache-2.0') }}

#include <generated/interface/{{ info.interface }}_req.hpp>

#include <everest/everest.hpp>
#include <everest/logging/logging.hpp>
#include <everest/utils/conversions.hpp>

namespace everest::interface::{{ info.interface }} {

{% for var in vars %}
{% if loop.first %}
//
// subscribe implementations
//
{% endif %}
void Subscribes::subscribe_{{ var.name }}(const std::function<void({% if var.json_type != 'null' %}{{ cpp_type(var) }}{% endif %})>& listener) {
    ValueCallback cb = [listener](const Value& value) {
        {% if var.json_type != 'null' %}
        auto native_value = {{ var_to_cpp(var) }}(value);
        listener(native_value);
        {% else %}
        if (value.type() != typeid({{ cpp_type(var) }})) {
            EVLOG(error) << "Callback for variable '{{ var.name }}' in interface '{{ info.interface }}' has wrong type!";
        }
        listener();
        {% endif %}
    };
    _ev->subscribe_var(_req, "{{ var.name }}", cb);
}

{% endfor %}
{% for cmd in cmds %}
{% if loop.first %}
//
// call implementations
//
{% endif %}
{{ call_cmd_signature(cmd, "Calls") }} {
    Parameters args;
    {% for arg in cmd.args %}
    args["{{ arg.name }}"] = {{ var_to_any(arg, arg.name) }};
    {% endfor %}
    {% if cmd.result %}Result result = {% endif %}_ev->call_cmd(_req, "{{ cmd.name }}", args);
    {% if cmd.result %}
    auto retval = {{ var_to_cpp(cmd.result) }}(result.get());

    return retval;
    {% endif %}
}

{% endfor %}
//
// requirement constructors
//
BootRequirement::BootRequirement(Everest* ev, const Requirement& req, const std::string& module_id) :
    Subscribes(ev, req), module_id(module_id){};

RunRequirement::RunRequirement(Everest* ev, const Requirement& req, const std::string& module_id) :
    Calls(ev, req), Subscribes(ev, req), module_id(module_id){};
}
