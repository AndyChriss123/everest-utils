{% from "helper_macros.j2" import print_template_info, print_spdx_line %}
{{ print_spdx_line('Apache-2.0') }}
{{ print_template_info('4') }}

#include <generated/module/{{ info.name }}.hpp>

#include <everest/generated_module.hpp>

namespace intf = everest::interface;

static auto parse_config_sets(const nlohmann::json& config_sets) {
    module::Configs cfg;

    {% for impl in configs.implementations %}
    {% for item in impl.config %}
    cfg.implementation.{{ impl.id }}.{{ item.name }} = everest::generated::safe_cast_to_{{ item.typename }}(
        config_sets.at("implementations").at("{{ impl.id }}").at("{{ item.name }}"));
    {% endfor %}

    {% endfor %}
    {% for item in configs.module %}
    cfg.module.{{ item.name }} = everest::generated::safe_cast_to_{{ item.typename }}(config_sets.at("module").at("{{ item.name }}"));
    {% endfor %}

    return cfg;
}

namespace module {

void load(const char* module_id, ModuleBase& module) {

    everest::Module::InterfaceMap interfaces = everest::InterfaceMapBuilder()
    {% for req in requires %}
        .add("{{ req.type }}", intf::{{ req.type }}::get_definition())
    {% endfor %}
    {% for impl in implementations %}
        .add("{{ impl.type }}", intf::{{ impl.type }}::get_definition())
    {% endfor %}
    ;

    auto manifest = everest::schema::parse_module(get_definition());

    auto module_info = everest::ModuleInfo {
        "{{ info.name }}",
        manifest.metadata.authors,
        manifest.metadata.license,
        module_id,
    };

    auto mod = everest::Module {
        module_id,
        everest::schema::parse_module(get_definition()),
        std::move(interfaces),
    };

    auto module_peer = everest::ModulePeer(mod);

    auto io_sync_exited = module_peer.spawn_io_sync_thread();

    auto config = module_peer.say_hello();

    auto config_sets = parse_config_sets(config.get_config_sets());

    {% for req in requires %}
    auto r_{{ req.id }} = everest::generated::RequirementHelper<intf::{{ req.type }}::BootRequirement, intf::{{ req.type }}::RunRequirement> {
        module_peer,
        config.get_fulfillments("{{ req.id }}"),
        "{{ req.id }}",
    };
    {% endfor %}

    BootContext boot_ctx {
        config_sets,
        {% for req in requires %}
        r_{{ req.id }}.boot{{ '[0]' if not req.is_vector }},
        {% endfor %}
        {% if info.enable_external_mqtt %}
        everest::ExternalMQTT(module_peer),
        {% endif %}
        module_info,
    };

    auto impls = module.init(boot_ctx);

    RunContext ctx {
        config_sets,
        {% for req in requires %}
        r_{{ req.id }}.run{{ '[0]' if not req.is_vector }},
        {% endfor %}
        {% for impl in implementations %}
        intf::{{ impl.type }}::Publishers(everest::ImplementationContext{module_peer, "{{ impl.id }}"}),
        {% endfor %}
        {% if info.enable_external_mqtt %}
        everest::ExternalMQTT(module_peer),
        {% endif %}
        module_info,
    };

    {% for impl in implementations %}
    impls.{{ impl.id }}.do_register(everest::ImplementationContext{module_peer, "{{ impl.id }}"}, &ctx.impl_{{ impl.id }});
    {% endfor %}

    module.setup(ctx);

    module_peer.init_done();

    module.ready();

    io_sync_exited.wait();
}

}
